# JWT 整合步驟指南 - 以 VendorProfile 為例
# 版本：1.4
# 最後更新：2024-03-19

## 一、版本比較

### 1.1 舊版本 (VendorProfileController.java)
```java
@Controller
public class VendorProfileController {
    // 1. 使用 @Controller 而不是 @RestController
    // 2. 沒有權限控制註解
    // 3. 使用 @RequestParam 接收參數
    // 4. 直接返回 Model 和視圖名稱
    // 5. 沒有 JWT 相關的驗證
}
```

### 1.2 新版本 (JWTVendorProfileController.java)
```java
@RestController
@RequestMapping("/api/vendor")
@PreAuthorize("hasRole('VENDOR')")
public class JWTVendorProfileController {
    // 1. 使用 @RestController 直接返回 JSON
    // 2. 添加權限控制註解
    // 3. 使用 JWT 進行身份驗證
    // 4. 統一的錯誤處理
    // 5. 使用 DTO 處理序列化
}
```

### 1.3 主要差異
1. **架構改變**：
   - 舊版：使用 MVC 模式，返回視圖
   - 新版：使用 RESTful API，返回 JSON

2. **安全性提升**：
   - 舊版：沒有權限控制
   - 新版：添加 `@PreAuthorize` 註解

3. **認證方式**：
   - 舊版：使用 email 和 password 參數
   - 新版：使用 JWT token 驗證

4. **錯誤處理**：
   - 舊版：簡單的錯誤返回
   - 新版：統一的錯誤處理和日誌記錄

5. **數據處理**：
   - 舊版：直接返回實體對象
   - 新版：使用 DTO 處理序列化問題

## 二、整合步驟

### 2.1 添加必要的依賴
在 `pom.xml` 中添加：
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

### 2.2 修改類別註解
```java
@RestController
@RequestMapping("/api/vendor")
@PreAuthorize("hasRole('VENDOR')")  // 添加權限控制
public class VendorProfileController {
    // ... 其他代碼
}
```

### 2.3 添加必要的導入
```java
import org.springframework.security.access.prepost.PreAuthorize;
import petTopia.jwt.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
```
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory; 
//這兩個可以添加錯誤日誌 可用可不用


### 2.4 注入 JwtUtil
```java
@Autowired
private JwtUtil jwtUtil;
```

### 2.5 修改方法實現
```java
@GetMapping("/profile")
public ResponseEntity<Map<String, Object>> getVendorProfile(HttpServletRequest request) {
    try {
        // 1. 獲取並驗證 token
        String token = getTokenFromRequest(request);
        if (token == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(Map.of("error", "請先登入"));
        }

        // 2. 從 token 獲取用戶 ID
        Integer userId = jwtUtil.extractUserId(token);
        if (userId == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(Map.of("error", "無效的令牌"));
        }

        // 3. 處理業務邏輯
        Optional<Vendor> vendorDetail = vendorRepository.findById(userId);
        if (vendorDetail.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(Map.of("error", "找不到商家資料"));
        }

        // 4. 返回結果
        return ResponseEntity.ok(Map.of("vendor", vendorDetail.get()));
    } catch (Exception e) {
        logger.error("獲取商家資料失敗", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(Map.of("error", "獲取商家資料失敗：" + e.getMessage()));
    }
}

// 輔助方法：從請求中獲取 token
private String getTokenFromRequest(HttpServletRequest request) {
    String authHeader = request.getHeader("Authorization");
    if (authHeader != null && authHeader.startsWith("Bearer ")) {
        return authHeader.substring(7);
    }
    return null;
}
```

## 三、前端整合

### 3.1 發送請求時添加 Token
```javascript
// 設置請求頭
axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;

// 發送請求
axios.get('/api/vendor/profile')
  .then(response => {
    // 處理響應
  })
  .catch(error => {
    // 處理錯誤
  });
```

### 3.2 處理 Token 過期
```javascript
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response.status === 401) {
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

## 四、Postman 測試

### 4.1 環境設置
1. 創建環境變量：
   - `base_url`: http://localhost:8080
   - `token`: 登入後獲取的 JWT token

### 4.2 測試端點
```http
# 登入獲取 Token
POST {{base_url}}/api/auth/login
Content-Type: application/json
{
    "email": "your-email@example.com",
    "password": "your-password"
}

# 獲取商家資料
GET {{base_url}}/api/vendor/profile
Authorization: Bearer {{token}}

# 更新商家資料
PUT {{base_url}}/api/vendor/profile
Authorization: Bearer {{token}}
Content-Type: multipart/form-data
vendorName: 新商家名稱
contactEmail: new@example.com
```

## 五、注意事項

1. 所有需要認證的端點都必須添加 `@PreAuthorize` 註解
2. 使用 `HttpServletRequest` 獲取 token
3. 實現適當的錯誤處理和日誌記錄
4. 確保資源訪問權限控制
5. 注意 CORS 配置

## 六、常見問題

### 6.1 Token 相關
- 過期：401 錯誤，重定向到登入頁
- 無效：返回 "無效的令牌" 錯誤
- 缺失：返回 "請先登入" 錯誤

### 6.2 權限相關
- 無權限：403 錯誤
- 未登入：401 錯誤

### 6.3 跨域問題
- 已在 SecurityConfig 中配置 CORS
- 允許的來源：http://localhost:5173, http://localhost:3000


