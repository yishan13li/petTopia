# JWT 認證系統使用指南
# 版本：1.0
# 最後更新：2024-03-19

## 一、基本概念

### 1.1 什麼是 JWT？
JWT (JSON Web Token) 是一種用於身份驗證的開放標準，它允許我們以安全的方式在各方之間傳遞信息。

## 二、Controller 使用方式

### 2.1 基本設置
```java
@RestController
@RequestMapping("/api/vendor")
@PreAuthorize("hasRole('VENDOR')")  // 權限控制
public class VendorController {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    // 獲取當前用戶信息
    @GetMapping("/profile")
    @PreAuthorize("hasRole('VENDOR')")  // 權限控制
    public ResponseEntity<?> getVendorProfile() {
        // 獲取當前認證用戶
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth.getName();
        
        // 處理業務邏輯
        return ResponseEntity.ok(vendorService.getProfile(username));
    }
    
    // 2. 更新商家資料
    @PutMapping("/profile")
    @PreAuthorize("hasRole('VENDOR')")
    public ResponseEntity<?> updateVendorProfile(@RequestBody VendorProfileDTO profile) {
        // 獲取當前用戶 ID
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String token = auth.getCredentials().toString();
        Integer userId = jwtUtil.extractUserId(token);
        
        // 處理更新邏輯
        return ResponseEntity.ok(vendorService.updateProfile(userId, profile));
    }
}
```

### 2.2 權限控制
```java
// 1. 方法級別權限控制
@PreAuthorize("hasRole('VENDOR')")
@GetMapping("/dashboard")
public ResponseEntity<?> getDashboard() {
    // 處理邏輯
}

// 2. 類級別權限控制
@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")
public class AdminController {
    // 所有方法都需要 ADMIN 權限
}

// 3. 多角色控制
@PreAuthorize("hasAnyRole('VENDOR', 'ADMIN')")
@GetMapping("/reports")
public ResponseEntity<?> getReports() {
    // 處理邏輯
}
```

### 2.3 獲取用戶信息
```java
// 1. 獲取用戶名
String username = SecurityContextHolder.getContext().getAuthentication().getName();

// 2. 獲取用戶 ID
String token = SecurityContextHolder.getContext().getAuthentication().getCredentials().toString();
Integer userId = jwtUtil.extractUserId(token);

// 3. 獲取用戶角色
String userRole = jwtUtil.extractUserRole(token);

// 4. 獲取完整用戶信息
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
UserDetails userDetails = (UserDetails) auth.getPrincipal();
```

## 三、安全最佳實踐

### 3.1 請求頭設置
```javascript
// 前端發送請求時
axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
```

### 3.2 錯誤處理
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(JwtAuthenticationException.class)
    public ResponseEntity<?> handleJwtException(JwtAuthenticationException ex) {
        return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .body(new ErrorResponse(ex.getMessage()));
    }
    
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex) {
        return ResponseEntity
            .status(HttpStatus.FORBIDDEN)
            .body(new ErrorResponse("沒有權限訪問此資源"));
    }
}
```

### 3.3 敏感操作驗證
```java
@PostMapping("/update-settings")
@PreAuthorize("hasRole('VENDOR')")
public ResponseEntity<?> updateSettings(@RequestBody SettingsDTO settings) {
    // 1. 驗證當前用戶
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    String username = auth.getName();
    
    // 2. 驗證操作權限
    if (!vendorService.hasPermission(username, settings.getOperationType())) {
        throw new AccessDeniedException("沒有權限執行此操作");
    }
    
    // 3. 執行更新
    return ResponseEntity.ok(vendorService.updateSettings(username, settings));
}
```

## 四、常見問題處理

### 4.1 Token 過期處理
```java
@ExceptionHandler(ExpiredJwtException.class)
public ResponseEntity<?> handleExpiredJwtException(ExpiredJwtException ex) {
    return ResponseEntity
        .status(HttpStatus.UNAUTHORIZED)
        .body(new ErrorResponse("登入已過期，請重新登入"));
}
```

### 4.2 無效 Token 處理
```java
@ExceptionHandler(JwtException.class)
public ResponseEntity<?> handleJwtException(JwtException ex) {
    return ResponseEntity
        .status(HttpStatus.UNAUTHORIZED)
        .body(new ErrorResponse("無效的認證令牌"));
}
```

## 五、開發建議

### 5.1 控制器設計
1. 使用適當的權限註解
2. 實現統一的錯誤處理
3. 使用 DTO 進行數據傳輸
4. 添加適當的日誌記錄

### 5.2 安全性考慮
1. 所有敏感操作都需要權限驗證
2. 實現請求頻率限制
3. 記錄重要操作日誌
4. 定期更換密鑰

### 5.3 性能優化
1. 使用緩存減少 Token 驗證開銷
2. 優化數據庫查詢
3. 實現異步處理

## 六、測試指南

### 6.1 單元測試
```java
@SpringBootTest
public class VendorControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Test
    public void testProtectedEndpoint() throws Exception {
        String token = jwtUtil.generateToken("testUser", 1, "VENDOR");
        mockMvc.perform(get("/api/vendor/profile")
            .header("Authorization", "Bearer " + token))
            .andExpect(status().isOk());
    }
}
```

### 6.2 整合測試
```java
@SpringBootTest
@AutoConfigureMockMvc
public class VendorIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Test
    public void testUpdateProfile() throws Exception {
        String token = jwtUtil.generateToken("testUser", 1, "VENDOR");
        VendorProfileDTO profile = new VendorProfileDTO();
        
        mockMvc.perform(put("/api/vendor/profile")
            .header("Authorization", "Bearer " + token)
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(profile)))
            .andExpect(status().isOk());
    }
}
```

## 七、注意事項

1. 永遠不要在響應中返回原始 Token
2. 定期檢查並更新安全配置
3. 實現適當的日誌記錄
4. 遵循最小權限原則
5. 定期進行安全審計
